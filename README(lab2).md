ОТЧЁТ по лабораторной работе по программированию на C++
Тема: "КОНТЕЙНЕРЫ STL И АЛГОРИТМЫ"
Цель работы
Освоение принципов работы с контейнерами стандартной библиотеки шаблонов (STL) C++: vector, deque, list. Изучение алгоритмов обработки данных, итераторов и методов работы с различными типами контейнеров.

Описание задач и их решения



ЗАДАНИЕ 1: Обмен средних элементов контейнеров
Описание: Даны вектор V, дек D и список L. Каждый исходный контейнер содержит не менее двух элементов, количество элементов является четным. Поменять значения двух средних элементов каждого из исходных контейнеров.

Решение:

// Обмен средних элементов в векторе
auto v1 = V.begin();
std::advance(v1, V.size() / 2 - 1);
auto v2 = V.begin();
std::advance(v2, V.size() / 2);
std::swap(*v1, *v2);
Алгоритм: Для каждого контейнера находятся итераторы на два средних элемента с помощью функции advance, затем их значения обмениваются с помощью алгоритма swap.

Тесты:
Для вектора V:
Введите количество элементов (четное, >= 2): 4
Введите число: 1
Введите число: 2
Введите число: 3
Введите число: 4

Для дека D:
Введите количество элементов (четное, >= 2): 6
Введите число: 10
Введите число: 20
Введите число: 30
Введите число: 40
Введите число: 50
Введите число: 60

Для списка L:
Введите количество элементов (четное, >= 2): 4
Введите число: 100
Введите число: 200
Введите число: 300
Введите число: 400

Результаты:
Вектор V: 1 3 2 4
Дек D: 10 20 40 30 50 60
Список L: 100 300 200 400



ЗАДАНИЕ 2: Добавление средних элементов в начало дека
Описание: Дан дек D с нечетным количеством элементов N(≥5). Добавить в начало дека пять его средних элементов в исходном порядке.

Решение:

// Находим 5 средних элементов
int start = n / 2 - 2;
int end = n / 2 + 3;

// Добавляем в начало
D.insert(D.begin(), D.begin() + start, D.begin() + end);
Алгоритм: Определяются индексы пяти средних элементов, затем эти элементы вставляются в начало дека с помощью одного вызова метода insert.

Тесты:
Введите количество элементов для дека (нечетное, >= 5): 7
Введите число: 1
Введите число: 2
Введите число: 3
Введите число: 4
Введите число: 5
Введите число: 6
Введите число: 7

Результат: 2 3 4 5 6 1 2 3 4 5 6 7



ЗАДАНИЕ 3: Перегруппировка элементов списка
Описание: Дан список L с элементами A1, A2, A3, …, AN−1, AN (N — четное). Изменить порядок элементов в списке на следующий: AN, A1, AN−1, A2, AN−2, …, AN/2, AN/2−1.

Решение:

auto i = L.begin();
auto r = L.end();
r--;

for (int count = 0; count < n / 2; count++) {
    L.splice(i, L, r);
    i++;
    r--;
}
Алгоритм: Используются два итератора - один с начала списка, другой с конца. В цикле элементы с конца перемещаются перед элементами с начала с помощью метода splice.

Тесты:
Введите количество элементов для списка (четное): 4
Введите число: 1
Введите число: 2
Введите число: 3
Введите число: 4

Результат: 4 1 3 2



ЗАДАНИЕ 4: Чтение чисел с нечетными номерами из файла
Описание: Дан текстовый файл с именем name, содержащий строковые представления целых чисел. Вывести числа из исходного файла с нечетными порядковыми номерами.

Решение:

int counter = 0;
int number = 0;
while (file >> number) {
    counter++;
    if (counter % 2 == 1) {
        std::cout << number << " ";
    }
}
Алгоритм: Числа читаются из файла последовательно, и выводятся только те, порядковый номер которых является нечетным.

Тесты:
Введите имя файла: numbers.txt
Числа с нечетными номерами: 10 30 50



ЗАДАНИЕ 5: Удаление второго нулевого элемента
Описание: Дан вектор V. Удалить второй из элементов вектора, равных нулю. Если нулевых элементов меньше двух, то вектор не изменять.

Решение:

// Ищем нулевые элементы
int zeroCount = 0;
int secondZeroIndex = -1;

for (int i = 0; i < V.size(); i++) {
    if (V[i] == 0) {
        zeroCount++;
        if (zeroCount == 2) {
            secondZeroIndex = i;
            break;
        }
    }
}
Алгоритм: Линейным поиском находится второй нулевой элемент, который затем удаляется с помощью метода erase.

Тесты:
Введите количество элементов для вектора: 5
Введите число: 1
Введите число: 0
Введите число: 2
Введите число: 0
Введите число: 3

Второй нулевой элемент удален
Результат: 1 0 2 3



ЗАДАНИЕ 6: Замена чисел в разных половинах вектора
Описание: Дан вектор V с четным количеством элементов. В первой половине исходного вектора заменить все отрицательные числа на −1, а во второй — все положительные числа на 1.

Решение:

// Первая половина - заменяем отрицательные на -1
for (int i = 0; i < n / 2; i++) {
    if (V[i] < 0) {
        V[i] = -1;
    }
}

// Вторая половина - заменяем положительные на 1
for (int i = n / 2; i < n; i++) {
    if (V[i] > 0) {
        V[i] = 1;
    }
}
Алгоритм: Вектор обрабатывается в два этапа - сначала первая половина, затем вторая, с заменой чисел согласно условию.

Тесты:
Введите количество элементов для вектора (четное): 6
Введите число: -2
Введите число: 5
Введите число: -1
Введите число: 3
Введите число: -4
Введите число: 6

Результат: -1 5 -1 1 -4 1



ЗАДАНИЕ 7: Сортировка списка по знаку чисел
Описание: Дан список L. Перегруппировать элементы списка, расположив в нем вначале отрицательные, затем нулевые, а затем положительные элементы.

Решение:
// Создаем три списка для разных типов чисел
std::list<int> negative, zero, positive;

for (int num : L) {
    if (num < 0) {
        negative.push_back(num);
    } else if (num == 0) {
        zero.push_back(num);
    } else {
        positive.push_back(num);
    }
}

// Объединяем списки
L.clear();
L.splice(L.end(), negative);
L.splice(L.end(), zero);
L.splice(L.end(), positive);
Алгоритм: Элементы распределяются по трем вспомогательным спискам в зависимости от знака, затем списки объединяются в нужном порядке.

Тесты:
Введите количество элементов для списка: 5
Введите число: 3
Введите число: -2
Введите число: 0
Введите число: -5
Введите число: 1

Результат: -2 -5 0 3 1



ЗАДАНИЕ 8: Вычисление средних арифметических соседних элементов
Описание: Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего арифметического для всех пар соседних элементов исходного списка.

Решение:
// Вычисляем средние арифметические соседних элементов
auto it1 = L.begin();
auto it2 = L.begin();
it2++;

while (it2 != L.end()) {
    double average = (*it1 + *it2) / 2.0;
    V.push_back(average);
    it1++;
    it2++;
}
Алгоритм: Используются два итератора для последовательного доступа к парам соседних элементов, вычисляются их средние арифметические.

Тесты:
Введите количество элементов для списка: 4
Введите число: 1
Введите число: 3
Введите число: 4
Введите число: 6

Средние арифметические: 2 3.5 5


ЗАКЛЮЧЕНИЕ
Выводы

В ходе лабораторной работы были успешно реализованы 8 различных алгоритмов работы с контейнерами STL. Освоены принципы работы с векторами, деками и списками, а также основные алгоритмы обработки данных. Все функции протестированы и работают корректно.

Результаты

Все 8 задач реализованы в полном объеме
Создан удобный пользовательский интерфейс с меню выбора заданий
Реализована обработка ошибочных ситуаций и проверка входных данных
Освоены основные методы работы с контейнерами STL и итераторами
